# 5/10 (목)

## 1. Today I learend


## 2. Today I fonund out

해커톤 2일째이다. 오늘은 저번에 짜두었던 game 클래스를 fifteenPuzzle이라는 이름으로 수정하고, 이 클래스 안에 짜둔 메소드를 사용해 DOM을 조작하는 부분까지 진행했다. 

처음에 다차원 배열을 구해놓은 다차원 배열을 (만들어둔)flatten 함수를 이용해 일차원 배열로 풀어주고 data-idx라고 만들어두었던 어트리뷰트에 순서대로 넣어주면 되지 않을까 생각했다. 그런데 막상 구현되는 것을 보니 내 예상과 달랐고, 내가 무언가를 놓치고 있다는 생각이 들었다. 

보현씨랑 3가지 방법에 대해서 얘기를 나눴는데, 내가 하려던 방법이 일단 안되니 보현씨는 강사님이 하셨던 것처럼 다차원 배열처럼 마크업을 ROW와 COL의 중첩구조로 짜고 Nodelist의 forEach를 사용해 row, col로 타고들어가 각 col에 textContent로 텍스트를 뿌려주는 방법을 짜기로 했다.

보현씨가 공부하면서 해당 코드를 작업하는 동안 나도 내가 어디를 놓치고 있나 살펴봤는데, 그 다음에 생각한 것이 data-idx에 순차적으로 넣는게 일차원 배열의 index 위치에 있는 수가 아니라 data-cell이라는 어트리뷰트를 하나 만들고 그거를 0 - 15까지 순차적으로 지정해준 다음 일차원 배열의 해당 data-cell값의 인덱스를 구하는 식으로 하면 되지 않을까였다. 

그리고 결과는 생각한대로 되었다. 보현씨도 강사님이 만드신 방법과 유사하게 만드는데 성공했다.  
그리고 보현씨랑 코드를 공유하면서 설명을 하다보니 내 코드에 중복되는게 있다는 걸 알게되었다. 생각해보니 내가 만든 마크업의 div와 그 안의 텍스트는 바뀌지 않는 방식이기 때문에 어차피 data-cell이나 forEach를 돌렸을때 매개변수로 받는 index나 똑같은 거였다. 그래서 data-cell관련된 불필요한 마크업과 코드를 수정했다.

해커톤같은 협업의 좋은 점은 나도 짜놓고 내 코드를 여러번 보지 않으면 모르는데, '짜다보니 되나보다 뭐 이렇게 저렇게해서 되는 거겠지'하고 넘어갈 수 있는 부분을 같이 협업하는 사람에게도 이해시키려면 그렇게 어영부영 넘길 수만은 없다는 것이다. 보현씨한테 내가 짠 코드를 잘 이해시키려다보니 내 스스로도 이해가 되지 않아 다시 여러번 읽어봐야했고 그 과정에서 data-cell같은 코드를 더욱 해석하기 어렵게만 하는 불필요한 코드를 줄일 수 있었다. 그리고 그냥 설명하기에는 나 스스로도 잘 이해가 안되어서 그림을 그려가며 설명을 했는데, 설명을 하다보니 나도 내 코드가 어떤식으로 내 의도와 맞게 구현된 것인지 다시 검증할 수 있었다.

보현씨가 CSS가 좀 어렵다고 하셔서 마크업을 어떻게 짤지 먼저 구성해보고 애니메이션을 구현할 수 있도록 옆에서 설명을 드리면서 도움을 드렸다. 설명하다보니 나도 생각을 해보고 말하게 되니까 알고 있던 정보를 머리속에서 끄집어 내면서 헷갈리는 부분은 다시 MDN 문서를 찾아보게 되니까 직접 짜는 것 못지않게 공부가 되었다.  
중첩 Nodelist를 forEach로 타고 들어가서 addEventListner를 걸고 재정렬된 배열을 뿌려주기 위해 다시 중첩 NodeList를 탐색해서 textContet를 넣어주는 부분을 이해하기 어려워하셔서 이벤트 루프랑 태스크 큐에 대해 설명을 드렸는데 생각해보니 나도 그 그림이 기억이 안나서 다시 찾아봤다.  
덕분에 나도 다시 복습하고 다시 이해하는 과정을 거쳤다.

집에서는 CSS에서 [data-col=0 ~ 15]에 일일이 위치 찾아서 translate 값을 계산해 넣어준 부분을 scss에서 for문으로 활용해 줄였다. 그리고 바로 자기 전에 게임 한번 하면서 완료되었을 때 스코어랑 타이머 시간이 안들어왔던 부분 수정해야지 하고 잠깐 봤는데 웬걸 오류가 난 코드가 끝없이 발견되었다.

심지어 영원히 풀 수 없는 경우의 퍼즐까지 나타났다. 
강사님 게임의 콘솔에서 배열 이쁘게 보여주는 함수처럼 디버깅 함수를 추가해서 중간중간 콘솔로 설명과 함께 찍는 부분을 추가해가면서 수정했다. 
그리고 영원히 풀 수 없는 퍼즐이 나오는 이유는 생각해보니 수의 전이는 blank의 경우는 제외해야하는데 우리가 만든 배열의 blank값이 15이면 15뒤의 수는 15의 반전쌍이 되어서 이 역시 count되고 있었다. 이걸 생각해내는데 너무 오래 걸렸다.

내일은(아니 오늘은...) 오늘 수정한 부분을 보현씨에게 공유하고, 디자인도 잘 수정해봐야겠다.