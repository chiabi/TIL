# 누구나 자료 구조와 알고리즘

1장 자료 구조가 중요한 까닭
- [x] 1.1 배열: 기초 자료 구조
- [x] 1.2 읽기
- [x] 1.3 검색
- [x] 1.4 삽입
- [x] 1.5 삭제
- [x] 1.6 집합: 단 하나의 규칙이 효율성을 바꾼다
- [x] 1.7 마무리

2장 알고리즘이 중요한 까닭
- [x] 2.1 정렬된 배열
- [x] 2.2 정렬된 배열의 검색
- [x] 2.3 이진 검색
- [x] 2.4 이진 검색 대 선형 검색
- [x] 2.5 마무리

3장 빅 오 표기법
- [x] 3.1 빅 오: 단계 수 계산
- [x] 3.2 상수 시간과 선형 시간
- [x] 3.3 같은 알고리즘, 다른 시나리오
- [x] 3.4 세 번째 유형의 알고리즘
- [x] 3.5 로가리즘
- [x] 3.6 O(log N) 해석
- [x] 3.7 실제 예제
- [x] 3.8 마무리

4장 빅 오로 코드 속도 올리기
- [x] 4.1 버블 정렬
- [x] 4.2 버블 정렬 실제로 해보기
- [x] 4.3 버블 정렬 구현
- [x] 4.4 버블 정렬의 효율성
- [x] 4.5 이차 문제
- [x] 4.6 선형 해결법
- [x] 4.7 마무리

5장 빅 오를 사용하거나 사용하지 않는 코드 최적화
- [x] 5.1 선택 정렬
- [x] 5.2 선택 정렬 실제로 해보기
- [x] 5.3 선택 정렬 구현
- [x] 5.4 선택 정렬의 효율성
- [x] 5.5 상수 무시하기
- [x] 5.6 빅 오의 역할
- [x] 5.7 실제 예제
- [x] 5.8 마무리

6장 긍정적인 시나리오 최적화
- [x] 6.1 삽입 정렬
- [x] 6.2 삽입 정렬해보기
- [x] 6.3 삽입 정렬 구현
- [x] 6.4 삽입 정렬의 효율성
- [x] 6.5 평균적인 경우
- [x] 6.6 실제 예제
- [x] 6.7 마무리

7장 해시 테이블로 매우 빠른 룩업
- [x] 7.1 해시 테이블 소개
- [x] 7.2 해시 함수로 해싱
- [x] 7.3 재미와 이익, 특히 이익을 남길 유의어 사전 만들기
- [x] 7.4 충돌 해결
- [x] 7.5 훌륭한 충돌 조정
- [x] 7.6 실제 예제
- [x] 7.7 마무리

8장 스택과 큐로 간결한 코드 생성
- [x] 8.1 스택
- [x] 8.2 스택 다뤄보기
- [x] 8.3 큐
- [x] 8.4 큐 다뤄보기
- [x] 8.5 마무리

9장 재귀를 사용한 재귀적 반복
- [ ] 9.1 루프 대신 재귀
- [ ] 9.2 기저 조건
- [ ] 9.3 재귀 코드 읽기
- [ ] 9.4 컴퓨터의 눈으로 바라본 재귀
- [ ] 9.5 재귀 다뤄보기
- [ ] 9.6 마무리

10장 속도를 높이는 재귀 알고리즘
- [ ] 10.1 분할
- [ ] 10.2 퀵 정렬
- [ ] 10.3 퀵 정렬의 효율성
- [ ] 10.4 최악의 시나리오
- [ ] 10.5 퀵 셀렉트
- [ ] 10.6 마무리

11장 노드 기반 자료 구조
- [ ] 11.1 연결 리스트
- [ ] 11.2 연결 리스트 구현
- [ ] 11.3 읽기
- [ ] 11.4 검색
- [ ] 11.5 삽입
- [ ] 11.6 삭제
- [ ] 11.7 연결 리스트 다뤄보기
- [ ] 11.8 이중 연결 리스트
- [ ] 11.9 마무리

12장 이진 트리로 속도 향상
- [ ] 12.1 이진 트리
- [ ] 12.2 검색
- [ ] 12.3 삽입
- [ ] 12.4 삭제
- [ ] 12.5 이진 트리 다뤄보기
- [ ] 12.6 마무리

13장 그래프로 뭐든지 연결하기
- [ ] 13.1 그래프
- [ ] 13.2 너비 우선 탐색
- [ ] 13.3 그래프 데이터베이스
- [ ] 13.4 가중 그래프
- [ ] 13.5 데이크스트라의 알고리즘
- [ ] 13.6 마무리

14장 공간 제약 다루기
- [ ] 14.1 공간 복잡도에 빅 오 표기법 적용
- [ ] 14.2 시간과 공간 트레이드오프
- [ ] 14.3 마치면서